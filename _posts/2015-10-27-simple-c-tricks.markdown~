---
layout: post
title:  "Simple C optimization tricks"
date:   2015-10-27 16:32:25
categories: c optimization
---

While talking to a user on reddit about their code I mentioned that it's usually better for your for loop to count down to zero from the result of a function call then count up to it. And they asked why?

It's a bit difficult to explain why unless you're an assembly programer (in which case it is obvious), but seeing what gcc does with both of them will help.

To that end I've created a simple C file and then used gcc -S to translate it to assembler. Both listings are at the bottom of the post but I'll show snippets of the relevent parts as needed.

Lets look at the first case shown here:

{% highlight c %}
for(i = 0; i < strlen(l); i++)
{% endhighlight %}

This was translated to the assemler code .L3 through .L2, in .L2, the first half checks to see if it should jumpt back to .L3 this is in effect the i <strlen(l) bit.
In the following code snipper -36(%rbp) is i, rbp is the base pointer which points to the base of the current frame, rsp is the stack pointer this points to the top of stack which will chase with pop/push's. -36(%rbp) is 28 bytes offset from rbp, the stack grows down so the address of i is lower than the base of the stack. -32(%rbp) is the address of the string we pass to strlen.

{% highlight gas %}
.L2:
	movl	-36(%rbp), %eax
	movslq	%eax, %rbx
	leaq	-32(%rbp), %rax
	movq	%rax, %rdi
	call	strlen
	cmpq	%rax, %rbx
	jb	.L3
{% endhighlight %}

It's clear to see it's 7 instructions long and includes a function call at very least a return. The first two instructions load rbx with i via eax. ebx is the 32bit register while rbx is the 64bit register. Now rax is loaded with the pointer (effective address) to the string which is passed to strlen via rdi ([the 64bit calling convention on sysv puts the first int argument in rdi](https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions)).
The result of strlen (in rax) is compared to rbx (i). Finally jump if rax > rbx to .L3

{% highlight c %}
for(i = strlen(l); i >= 0; --i)
{% endhighlight %}

This generated code .L5 to .L3

{% highlight gas %}
.L4:
	cmpl	$0, -36(%rbp)
	jns	.L5
{% endhighlight %}

Wow night and day... We simply compare i to 0 and [jump if not sign](https://en.wikipedia.org/wiki/Sign_flag) to .L5.

Had this been the old days we may have even used [LOOP _LABEL](http://www.c-jump.com/CIS77/reference/ISA/DDU0103.html) which is dec ecx and jz to _LABEL.

CX was always a register designed to handle loops and counters. However in the system v calling convention [RCX is designated caller save](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI) so may be clobbered by strlen().

One thing to note is that I wanted to compare pre and post increment effectiveness, in the past and certainly still in some embedded toolchains this can result in poor code because the compiler may not be smart enough to omptimize away the result from a post incrememnt.

Here is the code and output in it's entirity.

{% highlight c %}
	.file	"test.c"
	.section	.rodata
.LC0:
	.string	"%u\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	subq	$40, %rsp
	.cfi_offset 3, -24
	movq	%fs:40, %rax
	movq	%rax, -24(%rbp)
	xorl	%eax, %eax
	movl	$1684234849, -32(%rbp)
	movw	$26213, -28(%rbp)
	movb	$0, -26(%rbp)
	movl	$0, -36(%rbp)
	jmp	.L2
.L3:
	movl	-36(%rbp), %eax
	movl	%eax, %esi
	movl	$.LC0, %edi
	movl	$0, %eax
	call	printf
	addl	$1, -36(%rbp)
.L2:
	movl	-36(%rbp), %eax
	movslq	%eax, %rbx
	leaq	-32(%rbp), %rax
	movq	%rax, %rdi
	call	strlen
	cmpq	%rax, %rbx
	jb	.L3
	leaq	-32(%rbp), %rax
	movq	%rax, %rdi
	call	strlen
	movl	%eax, -36(%rbp)
	jmp	.L4
.L5:
	movl	-36(%rbp), %eax
	movl	%eax, %esi
	movl	$.LC0, %edi
	movl	$0, %eax
	call	printf
	subl	$1, -36(%rbp)
.L4:
	cmpl	$0, -36(%rbp)
	jns	.L5
	movl	$0, %eax
	movq	-24(%rbp), %rdx
	xorq	%fs:40, %rdx
	je	.L7
	call	__stack_chk_fail
.L7:
	addq	$40, %rsp
	popq	%rbx
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.2.1-22ubuntu2) 5.2.1 20151010"
	.section	.note.GNU-stack,"",@progbits
{% endhighlight %}

Enjoy,

Ali
